/**
 * Copyright (c) 2009, Lukas Eder, lukas.eder@gmail.com
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * . Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * . Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * . Neither the name of the "jOOQ" nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package org.jooq.util;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.SQLException;

import org.jooq.Field;
import org.jooq.impl.TableFieldImpl;
import org.jooq.impl.TableImpl;

/**
 * @author Lukas Eder
 */
public class DefaultGenerator implements Generator {

	private String targetPackageName;
	private String targetDirectory;

	@Override
	public void generate(Database database) throws SQLException, IOException {
		File dir = new File(targetDirectory);
		dir.mkdirs();
		
		File packageDir = new File(targetDirectory + File.separator + targetPackageName.replace('.', File.separatorChar));
		packageDir.mkdirs();
		
		System.out.println("Generating classes in " + packageDir.getCanonicalPath());
		
		for (TableDefinition table : database.getTables()) {
			String targetSchemaName = table.getSchema();
			String targetTableName = table.getName().toUpperCase();
			String targetClassName = getJavaClassName(targetTableName);
			String targetFileName = targetClassName + ".java";
			String targetComment = table.getComment();
			
			System.out.println("Generating table " + table.getName() + " into " + targetFileName);

			GenerationWriter out = new GenerationWriter(new PrintWriter(new File(packageDir, targetFileName)));
			out.println("/**");
			out.println(" * This class is generated by jOOQ");
			out.println(" */");
			out.println("package " + targetPackageName + ";");
			out.println();
			out.printImportPlaceholder();
			out.println();
			out.println("/**");
			out.println(" * This class is generated by jOOQ.");
			
			if (targetComment != null && targetComment.length() > 0) {
				out.println(" *");
				out.println(" * " + targetComment);
			}
			
			out.println(" */");
			out.println("public class " + targetClassName + " extends TableImpl {");
			out.printImport(TableImpl.class);
			out.println();
			out.println("\t/**");
			out.println("\t * The singleton instance of " + targetTableName);
			out.println("\t */");
			out.println("\tpublic static final " + targetClassName + " " + targetTableName + " = new " + targetClassName + "();");
			
			for (ColumnDefinition column : table.getColumns()) {
				Class<?> columnClass = column.getType();
				String columnType = columnClass.getSimpleName();
				String columnName = column.getName().toUpperCase();
				String columnComment = column.getComment();
				
				out.println();
				out.println("\t/**");
				
				if (columnComment != null && columnComment.length() > 0) {
					out.println("\t * " + columnComment);
				} else {
					out.println("\t * An uncommented column");
				}

				out.println("\t */");
				out.println("\tpublic static final Field<" + columnType + "> " + columnName + 
						" = new TableFieldImpl<" + columnType + ">(\"" 
						+ columnName + "\", " + columnType + ".class, " + targetTableName + ");");
				out.printImport(Field.class);
				out.printImport(TableFieldImpl.class);
				out.printImport(columnClass);
			}
			
			out.println();
			out.println("\t/**");
			out.println("\t * No further instances allowed");
			out.println("\t */");
			out.println("\tprivate " + targetClassName + "() {");
			out.println("\t\tsuper(\"" + targetTableName + "\", \"" + targetSchemaName + "\");");
			out.println("\t}");
			
			out.println("}");
			out.close();
		}
	}

	private String getJavaClassName(String tableName) {
		StringBuilder result = new StringBuilder();
		
		for (String word : tableName.split("_")) {
			result.append(word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase());
		}
		
		return result.toString();
	}

	@Override
	public void setTargetPackage(String packageName) {
		this.targetPackageName = packageName;
	}

	@Override
	public void setTargetDirectory(String directory) {
		this.targetDirectory = directory;
	}
}
